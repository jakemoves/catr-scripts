// bug: retrograde skips don't work properly, so I abandoned that feature - instead use resetToStart()

global proc createVrmesh(string $path, string $filename, string $object){
	updateFrame();
	select -r $object;
	log("creating vray mesh for current frame from " + $object + "\n", 1);
	log("file: " + $path + $filename, 1);
	vrayCreateProxy -exportType 1 -previewFaces 100000 -dir $path -fname $filename -ignoreHiddenObjects;
}

global proc createVrmeshes(int $start, int $end, string $object){
	string $path =  "/Volumes/Untitled 1/vraymeshtest/"; 
	string $filename;

	for($i = 0; $i < $end - $start + 1; ++$i){
		$filename = "vr_frame" + $i + ".vrmesh";
		currentTime -edit ($start + $i);
		createVrmesh($path, $filename, "take7:Mesh");
	}
}

global proc init(){
	log("init(): \n", 1);
	global string $loggingLevel;
    global int $currentTime;
    global int $lastTime;
    global float $playbackRange[];
    global string $filenameStem;
    global string $references[];
    global int $referenceStartFrames[];
    global int $referenceCurrentFrames[];
    global int $referenceNextFrames[];
    global string $referencePaths[];
    global string $effects[]; 
    global float $effectSettings[]; 
    global int $effectRanges[];
    global float $framesToAdvance[];

    // reset global variables to avoid requiring restarting Maya

    $filenameStem = "frame";

    // faking a class for references & obj sequence data
    $references = 				{ "frame1706RN3", "frame1706RN4", "frame1706RN5", "frame1706RN", "frame1706RN1", "frame1706RN2", "frame1706RN6", "frame1706RN7" };
    $referenceStartFrames =		{ 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 };
    $referenceCurrentFrames = 	{ 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 };
    $referenceNextFrames =		{ 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 };
    $referencePaths = 			{ 	
    								"/Volumes/CATR-MISC/catr-capture/jenna/take-9/",
    								"/Volumes/CATR-MISC/catr-capture/jenna/take-9/",
    								"/Volumes/CATR-MISC/catr-capture/jenna/take-9/",
    								"/Volumes/CATR-MISC/catr-capture/jenna/take-9/",
    								"/Volumes/CATR-MISC/catr-capture/jenna/take-9/",
    								"/Volumes/CATR-MISC/catr-capture/jenna/take-9/",
    								"/Volumes/CATR-MISC/catr-capture/jenna/take-9/",
    								"/Volumes/CATR-MISC/catr-capture/jenna/take-9/"
    							};
    $framesToAdvance =		{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

    // faking a class for timeline control / 'modes' / effects
    // play: effectSettings[0] is playback speed, effectSettings[1] is offset / delay / canon
    // ramp: effectSettings[0] is start speed, effectSettings[1] is end speed
    //		speed can be float below 1 but must be int above 1
    //		frame range is inclusive on floor, exclusive on ceiling (so we visualize it like a playhead between frames)
   	//		there needs to be a play call (even if it's a dummy) before any ramp calls to set the canon.
    $effects =					{ "play"	,	"ramp"		,	"ramp"		};
    $effectSettings =			{ 0.0, 24	,	0.05, 0.7  , 	0.7, 0.0  	};
    $effectRanges =				{ 679, 680	,	680, 1595	, 	1595, 2510	};
}

global proc resetToStart(){
	checkTime();

	global string $loggingLevel;
	global int $currentTime;
	global int $lastTime;
	global string $references[];
	global int $referenceStartFrames[];
	global int $referenceCurrentFrames[];
	global int $referenceNextFrames[];
    global float $playbackRange[];

	$loggingLevel = "1";
	// 0: no logging
	// 1: start and end states
	// 2: full logging (can add 30+ secs to each frame on render / playblast)

	$lastTime = $currentTime;
	$playbackRange[0] = `playbackOptions -q -minTime`; 
	$playbackRange[1] = `playbackOptions -q -maxTime`;

	for( $i = 0; $i < size($references); $i++){
		$referenceCurrentFrames[$i] = $referenceStartFrames[$i];
		$referenceNextFrames[$i] = $referenceStartFrames[$i];
	}

	updateMeshes();
	log(" control returned to resetToStart() >> " + "\n", 1);
}

global proc checkForSkipAhead(){
	// update times
	checkTime();
	global int $currentTime;
	//int $currentTime = `currentTime -query`;
	global int $lastTime;
	global string $loggingLevel;
	global float $playbackRange[];

	int $restoreLoggingSetting = 0;

	int $deltaT = $currentTime - $lastTime;

	log("checkForSkipAhead(): current frame is " + $currentTime + "; deltaT is " + $deltaT + "\n", 2);
	

	if($currentTime == trunc($playbackRange[0]) + 1){
		log("first frame of render \n", 1);
		$loggingLevel = 2;
	} else if($currentTime == trunc($playbackRange[1])){
		log("last frame of render \n", 1);
		$loggingLevel = 2;
	} else {
		$loggingLevel = 1;
	}

	if($deltaT != 0){
		if($deltaT == 1){
			updateState($currentTime);
			updateMeshes();
		} else /* we've jumped more than one frame forwards or backwards*/ {
			if($deltaT > 0){
				// disable logging for speed
				if($loggingLevel != 0){
					$restoreLoggingSetting = $loggingLevel;
					$loggingLevel = 0;
				}
				log("lastTime: " + $lastTime, 2);
				for( $i = $lastTime+1; $i <= $currentTime; ++$i){
					updateState($i);
				}
			} else if($deltaT < 0){
				log("WARNING: negative scrubbing is not supported, please call resetToStart manually and scrub forward" + "\n", 1);
			}
			// restore logging to original state
			if($restoreLoggingSetting != "0"){
				$loggingLevel = $restoreLoggingSetting;
			}
			updateMeshes(); 
		}
	}

	$lastTime = $currentTime;
}

global proc updateState(int $frame){
	log("updateState($frame: " + $frame + "): \n", 2);
	global string $references[];
	global int $referenceStartFrames[];
	global int $referenceCurrentFrames[];
	global int $referenceNextFrames[];

	global string $effects[];
	global float $effectSettings[];
	global int $effectRanges[];
	global float $framesToAdvance[];

	
		
	for( $ref = 0; $ref < size($references); ++$ref ){
		// iterate through references
		log("$referenceCurrentFrames: ", 2);
		logArrayInt($referenceCurrentFrames, 2);
		log("$referenceNextFrames: ", 2);
		logArrayInt($referenceNextFrames, 2);
		float $refDelay = -1.0;
		
		for( $effect = 0; $effect < size($effects); ++$effect ){

			if($effects[$effect] == "play"){
				$refDelay = $ref*$effectSettings[$effect*2+1];
			} else if($effects[$effect] == "ramp"){
				for($j = $effect; $j > 0; $j--){
					if($effects[$j] == "play"){
						$refDelay = $ref*$effectSettings[$j*2+1];
					}
				}
			}

			log("$refDelay: " + $refDelay + "; ", 2);
			float $adjustedRange[] = { ($effectRanges[$effect*2] + $refDelay), ($effectRanges[$effect*2+1] + $refDelay) }; //adjusted for canon value
			log("$adjustedRange: ", 2);
			logArrayFloat($adjustedRange, 2);

			if($frame >= $adjustedRange[0] && $frame < $adjustedRange[1]) {
				// the playhead is in range of the current effect for this reference
				if($effects[$effect] == "play"){
					log("applying effect \"" + $effects[$effect] + "\" to reference " + $ref + "\n", 2);
					
					$framesToAdvance[$ref] = $framesToAdvance[$ref] + $effectSettings[$effect*2];
					int $truncFramesToAdvance = trunc($framesToAdvance[$ref]*pow(10,0)/*+0.5*/)/pow(10,0); /* round 'speed' value' by uncommenting 0.5 back in*/
					log("$framesToAdvance: " + $framesToAdvance[$ref] + ", trunc: " + $truncFramesToAdvance + "\n", 2);
					
					int $tempNextFrame = $referenceNextFrames[$ref];

					$referenceNextFrames[$ref] = $referenceNextFrames[$ref] + $truncFramesToAdvance; 

					$referenceCurrentFrames[$ref] = $tempNextFrame;
				

					// clean up & set for next frame
					if($framesToAdvance[$ref] >= 1){
						$framesToAdvance[$ref] = $framesToAdvance[$ref] - 1;
					}
				} else if($effects[$effect] == "ramp"){
					log("applying effect \"" + $effects[$effect] + "\" to reference " + $ref + "\n", 2);

					if($refDelay == -1.0){
						log("ERROR: Need a canon set with a play effect before calling ramp" + "\n", 2);
					} else {
						log("$refDelay: " + $refDelay + "; ", 2);
						float $adjustedRange[] = { ($effectRanges[$effect*2] + $refDelay), ($effectRanges[$effect*2+1] + $refDelay) }; //adjusted for canon value
						log("$adjustedRange: ", 2);
						logArrayFloat($adjustedRange, 2);

						float $lerpStart = $effectSettings[$effect*2];
						float $lerpEnd = $effectSettings[$effect*2+1];

						float $lerpFrameDelta = $adjustedRange[1] - $adjustedRange[0];

						float $lerpAmount = ($frame - $adjustedRange[0]) / $lerpFrameDelta;

						float $lerp = lerp($lerpStart, $lerpEnd, $lerpAmount);
						
						$framesToAdvance[$ref] = $framesToAdvance[$ref] + $lerp;
						int $truncFramesToAdvance = trunc($framesToAdvance[$ref]*pow(10,0)/*+0.5*/)/pow(10,0); /* round 'speed' value' by uncommenting 0.5 back in*/
						log("$lerpFrameDelta: " + $lerpFrameDelta + ", $lerpAmount: " + $lerp + ", $lerp: " + $lerp + ", $framesToAdvance: " + $framesToAdvance[$ref] + ", trunc: " + $truncFramesToAdvance + "\n", 2);
						
						int $tempNextFrame = $referenceNextFrames[$ref];

						$referenceNextFrames[$ref] = $referenceNextFrames[$ref] + $truncFramesToAdvance; 

						$referenceCurrentFrames[$ref] = $tempNextFrame;
					

						// clean up & set for next frame
						if($framesToAdvance[$ref] >= 1){
							$framesToAdvance[$ref] = $framesToAdvance[$ref] - 1; // should this add the remainder?
						}
					}
				} else {
					log("WARNING: frame " + $frame + " does not fall within any effect ranges \n", 2);
				}
			}
		}
	}
}

global proc updateMeshes(){
	log("updateMeshes(): " + "\n", 2);
	global string $references[];

	for($i = 0; $i < size($references); ++$i){
		updateReference($i);
	}
	log(" control returned to updateMeshes() >> \n", 2);
}

global proc updateReference(int $referenceIndex){
	log("updateReference($referenceIndex: " + $referenceIndex + "): \n", 2);
	global string $references[];
	global int $referenceStartFrames[];
	global int $referenceCurrentFrames[];
	global string $referencePaths[];
	
	global string $filenameStem;
	
	int $frameIndex;

	cycleCheck -e off;
	
	$frameIndex = $referenceCurrentFrames[$referenceIndex];
	loadFileIntoReference($referencePaths[$referenceIndex], $filenameStem, $frameIndex, $references[$referenceIndex]);

	//log("set reference current frame to " + $referenceCurrentFrames[$referenceIndex]);
	log(" control returned to updateReference >> ", 2);
}

global proc loadFileIntoReference(string $path, string $filenameStem, int $index, string $reference){
	string $filePath = $path + $filenameStem + $index + ".obj";
	log("loadFileIntoReference($filePath: " + $filePath + ") \n", 2);
	if( catch( file -loadReference $reference -type "OBJ" $filePath ){
		log("WARNING: end of OBJ sequence reached at index " + $index + "\n", 1);
	} else {
		// hide reference's meshShape
		string $referenceNodes[] = `referenceQuery -nodes $reference`;
		//log($referenceNodes);
		string $meshShape = $referenceNodes[1]; // probably super fragile
		string $attr = $meshShape + ".visibility";
		int $visible = getAttr($attr);
		if( $visible == 1){
			setAttr($attr, 0); 
		}
	}
}

global proc log(string $text, int $level){
	global string $loggingLevel;

	if($loggingLevel == "0"){
		// no logging
	} else if($loggingLevel == "1"){
		// limited logging
		if($level == 1){
			print($text);
		}
	} else if($loggingLevel == "2"){
		// full logging
		if($level >= 1){
			print($text);
		}
	}
}

global proc logArrayInt(int $array[], int $level){
	global string $loggingLevel;
	if($loggingLevel == "0"){
		// no logging
	} else if($loggingLevel == "1"){
		// limited logging
		if($level == 1){
			print("{ ");
			for( $i = 0; $i < size($array); ++$i){
				print($array[$i]);
				if($i != size($array) - 1){
					print(", ");
				}
			}
			print(" }" + "\n");
		}
	} else if($loggingLevel == "2"){
		// full logging
		if($level >= 1){
			print("{ ");
			for( $i = 0; $i < size($array); ++$i){
				print($array[$i]);
				if($i != size($array) - 1){
					print(", ");
				}
			}
			print(" }" + "\n");
		}
	}
}

global proc logArrayFloat(float $array[], int $level){
	global string $loggingLevel;
	if($loggingLevel == "0"){
		// no logging
	} else if($loggingLevel == "1"){
		// limited logging
		if($level == 1){
			print("{ ");
			for( $i = 0; $i < size($array); ++$i){
				print($array[$i]);
				if($i != size($array) - 1){
					print(", ");
				}
			}
			print(" }" + "\n");
		}
	} else if($loggingLevel == "2"){
		// full logging
		if($level >= 1){
			print("{ ");
			for( $i = 0; $i < size($array); ++$i){
				print($array[$i]);
				if($i != size($array) - 1){
					print(", ");
				}
			}
			print(" }" + "\n");
		}
	}
}

global proc float lerp(float $start, float $end, float $value){
	float $lerp;
	$lerp = (1.0 - $value) * $start + $value * $end;
	return $lerp;
}

global proc checkTime(){
    global int $currentTime;
    $currentTime = `currentTime -query`;
    //log("current time: " + $currentTime + "\n", 2);
}
